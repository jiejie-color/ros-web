<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <!-- 禁止缩放 -->
    <title>机器人控制</title>
    <style>
      /* 添加摇杆样式 */
      .robot-controls {
        display: block;
        position: relative;
        min-height: 100vh; /* 确保覆盖整个屏幕高度 */
      }
      .joysticks-wrapper {
        position: fixed; /* 固定在屏幕底部 */
        bottom: 20px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between; /* 左右分布 */
        padding: 0 20px; /* 左右边距 */
        gap: 0;
        margin: 0;
      }
      .joystick-container {
        width: 150px; /* 手机端缩小摇杆尺寸 */
        height: 150px;
        background: rgba(50, 50, 50, 0.8);
        border-radius: 50%;
        position: relative;
      }
      .joystick-handle {
        width: 60px;
        height: 60px;
        background: radial-gradient(
          circle at 65% 35%,
          #999,
          #444
        ); /* 调整渐变颜色更柔和 */
        border-radius: 50%;
        position: absolute;
        /* 移除初始transform，改用left/top定位（避免与动态设置的transform冲突） */
        top: calc(50% - 30px); /* 60px高度的一半 */
        left: calc(50% - 30px); /* 60px宽度的一半 */
        transition: all 0.1s ease-out; /* 改为all过渡，包含位置和可能的缩放 */
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4); /* 调整阴影更轻薄 */
        cursor: pointer;
      }
      .joystick-handle:active {
        transform: scale(0.95); /* 添加按下时的微缩反馈 */
      }
      .joystick-handle:active {
        transform: scale(0.95); /* 添加按下时的微缩反馈 */
      }

      #control-status {
        text-align: center;
        font-size: 14px; /* 缩小状态文字 */
        padding: 10px;
        background: rgba(0, 0, 0, 0.1);
        position: fixed; /* 固定在顶部 */
        top: 0;
        left: 0;
        right: 0;
      }
    </style>
  </head>

  <body>
    <!-- 双摇杆控制界面（布局调整） -->
    <div class="robot-controls">
      <div id="control-status" style="margin-top: 0"></div>
      <div
        style="
          position: fixed;
          top: 50px;
          left: 50%;
          transform: translateX(-50%);
          text-align: center;
        "
      >
        <label for="max-speed">最大速度：</label>
        <input type="range" id="max-speed" min="0" max="500" value="200" />
        <span id="current-speed">200</span>
      </div>
      <!-- 移除原有margin -->
      <div class="joysticks-wrapper">
        <!-- 速度摇杆（固定在左下角） -->
        <div class="joystick-container" id="speed-joystick">
          <div class="joystick-handle handle1"></div>
        </div>
        <!-- 方向摇杆（固定在右下角） -->
        <div class="joystick-container" id="direction-joystick">
          <div class="joystick-handle handle2"></div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        window.addEventListener("gamepadconnected", (e) => {
          startPollingGamepads(); // 开始轮询摇杆状态
        });

        window.addEventListener("gamepaddisconnected", (e) => {
          statusElement.textContent = "摇杆已断开";
          statusElement.style.color = "red";
          stopPollingGamepads(); // 停止轮询
        });
        let gamepadPolling = null;

        // 启动摇杆轮询（60Hz频率）
        function startPollingGamepads() {
          if (!gamepadPolling) {
            gamepadPolling = setInterval(updateGamepadState, 16); // 约60Hz
          }
        }

        // 停止摇杆轮询
        function stopPollingGamepads() {
          if (gamepadPolling) {
            clearInterval(gamepadPolling);
            gamepadPolling = null;
          }
        }

        // 更新摇杆状态并计算控制参数
        function updateGamepadState() {
          const gamepads = navigator.getGamepads();
          const pad = gamepads[0]; // 假设使用第一个连接的摇杆

          if (!pad) return;

          // 左摇杆（轴0: X, 轴1: Y）控制移动
          const leftX = clamp(pad.axes[0], -1, 1); // 范围-1~1
          const leftY = clamp(pad.axes[1], -1, 1);

          // 右摇杆（轴2: X, 轴3: Y）控制旋转（仅用X轴）
          const rightX = clamp(pad.axes[2], -1, 1);

          // 转换为控制参数（与虚拟摇杆范围对齐）
          currentVx = Math.round(-leftY * maxSpeed); // Y轴上推为负→vx正（前进）
          currentVy = Math.round(-leftX * maxSpeed); // X轴右推为正→vy正（右移）
          currentVtheta = Math.round(-rightX * 1); // 右摇杆X轴控制旋转

          const now = Date.now();
          if (now - lastSendTime >= throttleDelay) {
            sendControlCommand(currentVx, currentVy, currentVtheta);
            lastSendTime = now;
          }
        }

        // 数值范围限制函数
        function clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
        }
        // 获取两个摇杆元素
        const speedJoystick = document.getElementById("speed-joystick");
        const directionJoystick = document.getElementById("direction-joystick");
        const statusElement = document.getElementById("control-status");
        // const apiUrl = "http://192.168.18.60:5000/set_vel";
        const ws = new WebSocket(`ws://${window.location.hostname}:8765`);
        // WebSocket连接状态处理
        ws.onopen = () => {
          statusElement.textContent = "WebSocket连接成功";
          statusElement.style.color = "green";
        };

        ws.onmessage = (event) => {
          statusElement.textContent = `接收响应：${event.data}`;
          statusElement.style.color = "blue";
        };

        ws.onerror = (error) => {
          statusElement.textContent = `WebSocket错误：${error.message}`;
          statusElement.style.color = "red";
        };

        ws.onclose = () => {
          statusElement.textContent = "WebSocket连接已关闭";
          statusElement.style.color = "orange";
        };

        const maxRadius = 80;
        const throttleDelay = 250;
        let lastSendTime = 0;
        let currentVx = 0,
          currentVy = 0,
          currentVtheta = 0; // 实时参数缓存

        const maxSpeedInput = document.getElementById("max-speed");
        const currentSpeedDisplay = document.getElementById("current-speed");
        let maxSpeed = parseInt(maxSpeedInput.value); // 初始化最大速度

        // 监听速度调节变化
        maxSpeedInput.addEventListener("input", (e) => {
          maxSpeed = parseInt(e.target.value);
          currentSpeedDisplay.textContent = maxSpeed;
        });

        // 通用摇杆处理函数（参数：摇杆元素，是否是速度摇杆）
        function initJoystick(joystickElement, isSpeedJoystick) {
          joystickElement.addEventListener("mousedown", handleInputStart);
          joystickElement.addEventListener("touchstart", handleInputStart);

          function handleInputStart(e) {
            e.preventDefault();
            const rect = joystickElement.getBoundingClientRect();
            const center = {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2,
            };

            const handle = joystickElement.querySelector(".joystick-handle");

            function handleMove(e) {
              const touch = e.touches ? e.touches[0] : e;
              const deltaX = touch.clientX - center.x;
              const deltaY = touch.clientY - center.y;
              const limitedX = Math.min(
                Math.max(deltaX, -maxRadius),
                maxRadius
              );
              const limitedY = Math.min(
                Math.max(deltaY, -maxRadius),
                maxRadius
              );
              handle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;

              if (isSpeedJoystick) {
                currentVx = Math.round((-limitedY / maxRadius) * maxSpeed);
                currentVy = Math.round((-limitedX / maxRadius) * maxSpeed);
              } else {
                currentVtheta = Math.round((-limitedX / maxRadius) * 1);
              }

              const now = Date.now();
              if (now - lastSendTime >= throttleDelay) {
                sendControlCommand(currentVx, currentVy, currentVtheta);
                lastSendTime = now;
              }
            }

            function handleEnd() {
              handle.style.transform = `translate(0, 0)`;
              if (isSpeedJoystick) {
                currentVx = 0;
                currentVy = 0;
              } else {
                currentVtheta = 0;
              }
              sendControlCommand(currentVx, currentVy, currentVtheta);

              document.removeEventListener("mousemove", handleMove);
              document.removeEventListener("touchmove", handleMove);
              document.removeEventListener("mouseup", handleEnd);
              document.removeEventListener("touchend", handleEnd);
            }

            document.addEventListener("mousemove", handleMove);
            document.addEventListener("touchmove", handleMove);
            document.addEventListener("mouseup", handleEnd);
            document.addEventListener("touchend", handleEnd);
          }
        }

        // 初始化两个摇杆
        initJoystick(speedJoystick, true);
        initJoystick(directionJoystick, false);

        // 发送控制指令（更新状态显示）
        async function sendControlCommand(vx, vy, vtheta) {
          if (ws.readyState !== WebSocket.OPEN) {
            statusElement.textContent = "WebSocket未连接，无法发送指令";
            statusElement.style.color = "red";
            return;
          }

          const command = JSON.stringify({ vx, vy, vtheta });
          ws.send(command);
          // statusElement.textContent = `指令发送：vx=${vx}, vy=${vy}, vtheta=${vtheta}`;
          // statusElement.style.color = "green";
        }
      });
    </script>
  </body>
</html>
